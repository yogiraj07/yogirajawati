package com.mapreduce.main;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.zip.GZIPInputStream;

import com.opencsv.CSVReader;
import com.sun.org.apache.xerces.internal.impl.xpath.regex.ParseException;

public class CsvGzReader {


	private String COMMA_SEP = ",";
	private ArrayList<String> csvHeader = new ArrayList<String>();
	private HashMap<String, Float> ticketPriceMap = new HashMap<String, Float>();
	
	public void decompressGzipFile(String gzipFile) throws java.text.ParseException {
		long validCount = 0;
        long invalidCount = 0;
        
		
		try {
        	InputStream fileStream = new FileInputStream(gzipFile);
        	InputStream gzipStream = new GZIPInputStream(fileStream);
        	Reader decoder = new InputStreamReader(gzipStream, "ASCII");
        	CSVReader buffered = new CSVReader(decoder);
           
            String[] line;
            
            csvHeader = new ArrayList(Arrays.asList(buffered.readNext()));
            
            while((line = buffered.readNext())!=null){
                
            	if(isLineValid(line)){
            		validCount += 1;
            		
            	} else {
            		invalidCount += 1;
            	}
            	
            	
//				for (String field : fields){
//					System.out.print(field + " ");
//				}
//				System.out.print("\n");
            
            }
            
            buffered.close();
            decoder.close();
            
        } catch (IOException e) {
        	System.err.println("UNABLE TO DECOMPRESS FILE:");
            e.printStackTrace();
        }
        
        // Print output
        
        System.out.println("Valid Count F = " + validCount);
        System.out.println("Corrupt Count K = " + invalidCount);
        System.out.println(ticketPriceMap.values().size() + " ");
    }
	
	
	private boolean isLineValid(String[] fields) throws java.text.ParseException {
		
//		for (String f: fields) System.out.print(f+" ");
//		for (String f: csvHeader) System.out.print(f+" ");
		float timeZone=0;
		
		// CRSArrTime and CRSDepTime should not be zero
		// timeZone % 60 should be 0
		
		SimpleDateFormat format = new SimpleDateFormat("HHmm");
		
		String CRS_ARR_TIME = fields[csvHeader.indexOf("CRS_ARR_TIME")];
		String CRS_DEP_TIME = fields[csvHeader.indexOf("CRS_DEP_TIME")];
		String CRS_ELAPSED_TIME = fields[csvHeader.indexOf("CRS_ELAPSED_TIME")];
	
		try{
			Date CRSArrTime = (CRS_ARR_TIME.equals("") ? null : format.parse(CRS_ARR_TIME));
			Date CRSDepTime = (CRS_DEP_TIME.equals("") ? null : format.parse(CRS_DEP_TIME));
			float CRSElapsedTime = Float.parseFloat(CRS_ELAPSED_TIME);
			
//			float crsDiff = (CRSArrTime.getTime() - CRSDepTime.getTime())/(60 * 1000) % 60;
			
			float crsDiff = (float) dateDiff(CRS_ARR_TIME, CRS_DEP_TIME);
			
			timeZone = crsDiff - CRSElapsedTime;
			
			if (CRSArrTime.getTime() == 0.0 || CRSDepTime.getTime() == 0.0) return false;
			
			if ((timeZone % 60) != 0) return false;
		} catch(NumberFormatException e) {
			return false;
		} catch (ParseException e) {
			return false;
		}
		
		
		
		
		// AirportID,  AirportSeqID, CityMarketID, StateFips, Wac should be larger than 0
		
		int ORIGIN_AIRPORT_ID = Integer.parseInt(fields[csvHeader.indexOf("ORIGIN_AIRPORT_ID")]);
		if (ORIGIN_AIRPORT_ID <= 0) return false;
		
		int ORIGIN_AIRPORT_SEQ_ID = Integer.parseInt(fields[csvHeader.indexOf("ORIGIN_AIRPORT_SEQ_ID")]);
		if (ORIGIN_AIRPORT_SEQ_ID <= 0) return false;
		
		int ORIGIN_CITY_MARKET_ID = Integer.parseInt(fields[csvHeader.indexOf("ORIGIN_CITY_MARKET_ID")]);
		if (ORIGIN_CITY_MARKET_ID <= 0) return false;
		
		int ORIGIN_STATE_FIPS = Integer.parseInt(fields[csvHeader.indexOf("ORIGIN_STATE_FIPS")]);
		if (ORIGIN_STATE_FIPS <= 0) return false;
		
		int ORIGIN_WAC = Integer.parseInt(fields[csvHeader.indexOf("ORIGIN_WAC")]);
		if (ORIGIN_WAC <= 0) return false;
		
		int DEST_AIRPORT_ID = Integer.parseInt(fields[csvHeader.indexOf("DEST_AIRPORT_ID")]);
		if (DEST_AIRPORT_ID <= 0) return false;
		
		int DEST_AIRPORT_SEQ_ID = Integer.parseInt(fields[csvHeader.indexOf("DEST_AIRPORT_SEQ_ID")]);
		if (DEST_AIRPORT_SEQ_ID <= 0) return false;
		
		int DEST_CITY_MARKET_ID = Integer.parseInt(fields[csvHeader.indexOf("DEST_CITY_MARKET_ID")]);
		if (DEST_CITY_MARKET_ID <= 0) return false;
		
		int DEST_STATE_FIPS = Integer.parseInt(fields[csvHeader.indexOf("DEST_STATE_FIPS")]);
		if (DEST_STATE_FIPS <= 0) return false;
		
		int DEST_WAC = Integer.parseInt(fields[csvHeader.indexOf("DEST_WAC")]);
		if (DEST_WAC <= 0) return false;
		
		// Origin, Destination,  CityName, State, StateName should not be empty

		String ORIGIN = fields[csvHeader.indexOf("ORIGIN")];
		if (ORIGIN.equals("")) return false;
		
		String ORIGIN_CITY_NAME = fields[csvHeader.indexOf("ORIGIN_CITY_NAME")];
		if (ORIGIN_CITY_NAME.equals("")) return false;
		
		String ORIGIN_STATE_ABR = fields[csvHeader.indexOf("ORIGIN_STATE_ABR")];
		if (ORIGIN_STATE_ABR.equals("")) return false;
		
		String ORIGIN_STATE_NM = fields[csvHeader.indexOf("ORIGIN_STATE_NM")];
		if (ORIGIN_STATE_NM.equals("")) return false;
		
		String DEST = fields[csvHeader.indexOf("DEST")];		
		if (DEST.equals("")) return false;
		
		String DEST_CITY_NAME = fields[csvHeader.indexOf("DEST_CITY_NAME")];
		if (DEST_CITY_NAME.equals("")) return false;
		
		String DEST_STATE_ABR = fields[csvHeader.indexOf("DEST_STATE_ABR")];
		if (DEST_STATE_ABR.equals("")) return false;
		
		String DEST_STATE_NM = fields[csvHeader.indexOf("DEST_STATE_NM")];
		if (DEST_STATE_NM.equals("")) return false;
		
		
		// For flights that are not Cancelled:
	
		int CANCELLED = Integer.parseInt(fields[csvHeader.indexOf("CANCELLED")]);		
		
		if (CANCELLED == 0){			
			
			String ARR_TIME = fields[csvHeader.indexOf("ARR_TIME")];
			String DEP_TIME = fields[csvHeader.indexOf("DEP_TIME")];
			String ACTUAL_ELAPSED_TIME = fields[csvHeader.indexOf("ACTUAL_ELAPSED_TIME")];
			
			try{
				Date arrTime = (ARR_TIME.equals("") ? null : format.parse(ARR_TIME));
				Date depTime = (DEP_TIME.equals("") ? null : format.parse(DEP_TIME));
				long actualElapsedTime = Long.parseLong(ACTUAL_ELAPSED_TIME);
//				long actualDiff = (arrTime.getTime() - depTime.getTime()) % 60;
				long actualDiff = dateDiff(ARR_TIME, DEP_TIME);
				
				long actualTimeZone = actualDiff - actualElapsedTime;

				Date CRSArrTime = (CRS_ARR_TIME.equals("") ? null : format.parse(CRS_ARR_TIME));
				Date CRSDepTime = (CRS_DEP_TIME.equals("") ? null : format.parse(CRS_DEP_TIME));
				long CRSElapsedTime = Long.parseLong(CRS_ELAPSED_TIME);
//				long crsDiff = (CRSArrTime.getTime() - CRSDepTime.getTime()) / (60 * 1000) % 60;
				long crsDiff = dateDiff(CRS_ARR_TIME, CRS_DEP_TIME);
				long newtimeZone = crsDiff - CRSElapsedTime;

				
				
//				System.out.println(ARR_TIME + " " + DEP_TIME + " " + actualDiff);

				
				if (actualTimeZone != newtimeZone) {
					return false;
				}
				
				
				else
				{

//				System.out.println();
//				System.out.println(arrTime + " " + " " + depTime + " " + actualDiff + " " + actualTimeZone);
//				System.out.println(CRSArrTime + " " + CRSDepTime + " " + crsDiff + " " + newtimeZone);
				}
				
				
				// TODO: fix
				// if ArrDelay > 0 then ArrDelay should equal to ArrDelayMinutes
				// if ArrDelay < 0 then ArrDelayMinutes should be zero
				// if ArrDelayMinutes >= 15 then ArrDel15 should be false
				
//				float arrDelay = Float.parseFloat(fields[csvHeader.indexOf("ARR_DELAY")]);
//				float ArrDelayMinutes = dateDiff(ARR_TIME, CRS_ARR_TIME);
//				float arrDel15 = Float.parseFloat(fields[csvHeader.indexOf("ARR_DEL15")]);
//				
//				if (arrDelay > 0){
//					if (arrDelay != ArrDelayMinutes) return false;
//				}
//				if (arrDelay < 0){
//					if (ArrDelayMinutes != 0) return false;
//				}
//				
//				if (ArrDelayMinutes >= 15){
//					if (arrDel15 == 1) return false;
//				}
				
				
			} catch(NumberFormatException e) {
				return false;
			} catch (ParseException e) {
				return false;
			}
			
			
			
		}
		
		// All validations passed
		return true;
	}
	
	private int dateDiff (String arr, String dep){
		if (Integer.parseInt(arr) > Integer.parseInt(dep)){
			return (Integer.parseInt(arr.substring(0, 2)) - Integer.parseInt(dep.substring(0, 2))) * 60 +
					(Integer.parseInt(arr.substring(2, 4)) - Integer.parseInt(dep.substring(2, 4)));
		} else {
			return (Integer.parseInt(arr.substring(0, 2)) - Integer.parseInt(dep.substring(0, 2)) + 24) * 60 +
					(Integer.parseInt(arr.substring(2, 4)) - Integer.parseInt(dep.substring(2, 4)));
		}
	}

}
